# 노트에 메모를 할 때 애초부터 개념 칸과 코드 칸을 분리해서 코드를 짜는 중간중간 개념을 깔끔하게 정리할 수 있도록 하기.
# 기능 칸 분리. 기능 칸에는 코드 진행과 상관없이 구현해야하는 아이디어를 메모해놓기.
# 변수에 대해서는 전역변수인지 여부, 선언을 하고 들어가는지 등등 따져봐야함. 
'''
예시를 가지고 먼저 이해하고 개념을 코드에 적용해보기
바로 입력값으로 가기엔 너무 부담스럽고 복잡해보인다면 같은 문제형식의 간단한 입력값이나 예시에 먼저 적용해보고
문제의 입력 예시로 넘어가기  
4 5
00110
00011
11111
00000

15 14
00000111100000
11111101111110
11011101101110
11011101100000
11011111111111
11011111111100
11000000011111
01111111111111
00000000011111
01111111111000
00011111111000
00000001111000
11111111110011
11100011111111
11100011111111
'''
# 함수 선언
def checkIce(row, column):
    # 이동 범위에 대한 제한(out of range 방지)
    if row <= -1 or row >= n or column <= -1 or column >= m:
        return False 
    if ice[row][column] == 0: # 현재 노드에 방문하지 않았다면 
        ice[row][column] = 1 # 현재 노드 방문 처리
        # 현재 노드와 연결된 다른 노드를 재귀적으로 방문 
        checkIce(row-1, column) # 위쪽 확인
        checkIce(row, column+1) # 오른쪽 확인
        checkIce(row+1, column) # 아래쪽 확인
        checkIce(row, column-1) # 왼쪽 확인 
        return True # 재귀적으로 방문한 뒤에 모두 다 확인했을 때는 True 반환하고 함수 종료 
    return False # 방문할 곳이 없다면 함수 종료 
# 입력받기
n, m = map(int, input().split())
ice = [] # 얼음 틀
for _ in range(n): 
    ice.append(list(map(int, input())))

# 메인 코드
count = 0 # 아이스크림 개수 
for i in range(n):
    for j in range(m):
        if checkIce(i, j) == True:
            count += 1 # 1회전하고 나면 연결된 얼음을 모두 확인했기 때문에 개수 += 1
# 출력
print(count)

'''
문제를 보고 그래프 형식으로 나타낼 수 있고, 한 노드에서 가능한 깊이, 멀리 탐색한다면 dfs를 생각해내기
dfs를 구현할 때는 스택보다는 재귀함수를 이용하는 것이 직관적

함수 종료는 False. True, False를 잘 활용하기
현재 노드 방문 후 해당 노드의 방문 처리하기
이후 재귀적으로 호출하기 

경우의 수를 따져봐야 하는데 
만약 방문할 수 있는 노드가 없다면 False를 리턴할 수 있어야 함. 
'''






